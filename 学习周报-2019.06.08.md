# 学习周报

2019.06.08 - 2019.06.15

## 2019.06.10

### TypeScript的学习

#### Rest and Spread 操作符

用处：

1. 接收参数，是一个数组

   ```ts
   function func1(...args){
   	args.forEach(function(arg){
   		console.log(arg)
   	})
   }
   
   func1(1, 2, 3)
   ```

2. 传递参数，入参是，形参是多个

   ```ts
   function func1(a, b, c){
   	console.log(a)
   	console.log(b)
   	console.log(c)
   }
   
   func1(...[1, 2])
   ```

#### 类 Class

1. class的属性的访问控制符，分为三种，公开的，私有的，被保护的

2. 构造器函数construtor在new一个实例的时候，会被调用一次

3. 类在某种意义上（我先这么分类，不知道是不是有这种界定）有两种属性的声明方式：形参（隐式声明），显示声明。

   ```ts
   class Person{
   
   	name; // 默认的访问控制符是，public
   	
   	construtor(age: string){};
   	
   	eat(){
   		console.log(this.name);
   		console.log(this.age); // 这里会报错，因为并没有显示声明age，必须在构造器的形参前，声明访问控制符为：public
   	};
   	
   }
   ```

4. 子类的构造函数如果有，就必须调用一下父类的构造函数，使用`super`关键字

5. `super`的另外一个用法是调用父类上面的方法

6. 不想被外界访问的方法或者属性就可以直接使用访问控制符`private`



#### 泛型

一种参数化的类型，一般用来限制集合

这种类型可以是推断的。

可以是类。

可以是接口。



#### 接口

用来建立某种**代码约定**，使得其他开发者在**调用**某种方法或者**创建**新的类时，必须遵循接口所定义的代码约定。

用法

1. 方法参数的类型声明
2. 实现这个接口的类
   * 当一个类实现一个接口的时候，这个类必须实现这个接口里面的方法



#### 模块 Module

将代码分割成可重用的单元。

可以决定哪些资源（类，方法，属性）暴露，哪些只在模块内部使用



#### 注解

注解是给指定的库、框架用的，告诉如何去处理程序的元素(属性、方法、类)



#### 类型定义文件`*.d.ts`

在TS是使用已有的JS的工具包、库



### Flow js的静态类型检查

#### 工作方式2种

* 类型推断

* 类型注释

注释的方式类似于TS，但是还是有一些不同的

1. 可以为 `null` 或者 `undefined`，如下

```js
/*@flow*/
var foo: ?string = null;
```

​	foo可以是字符串或者是null\undefined。

​	对于js的两种类型null\undefined，flow的类型是 `null` 和 `void`

​	可选类型的`?`是在类型的前面，`:`的后面

2. 强制类型转换的应用

   ```js
   // @flow
   function acceptsBoolean(value: boolean){}
   
   acceptsBoolean(0); // 必须传入布尔值
   // 可以进行如下转化
   acceptsBoolean(Boolean(0));
   acceptsBoolean(!!0);
   ```

3. 对象的可选属性

   ```js
   { propertyName?: string }
   ```

   在属性键的后面。

4. 值可以限制成确定的值，使用冒号

5. 类型使用`mixed`可以是用在形参上，所有类型的值都可以传入，但是

   1. 有返回值，要确定值类型，这个形参在函数内部需要进行类型检查之后才可以使用。
   2. 没有返回值，那无所谓了


别的flow的内容，在vue源码阅读的过程中，再看。



### vue源码阅读

#### Flow 在 Vue.js 源码中的应用

关键词： `libdef`，`Rollup`

`libdef`： 可以用来识别这些第三方库或者是自定义类型



vuejs基于Rollup构建，vue的构建打包过程，有很多版本的vuejs。Rollup的配置文件`scripts/config.js`，先从配置文件读取配置，再通过命令行参数对构建配置做过滤，各版本的对应的入口在`entry: resolve('xxx/xxx.js'),`，最终编译的版本在` dest: resolve('dist/xxx.js')`。

构建的时候执行，`node scripts/build.js`，这个文件是构建的入口。

```js
// 获取各种构建方式的配置
let builds = require('./config').getAllBuilds()

// 构建语句的环境参数有没有，node scripts/build.js， 是没有的
if (process.argv[2]) {
  const filters = process.argv[2].split(',')
  builds = builds.filter(b => {
    return filters.some(f => b.output.file.indexOf(f) > -1 || b._name.indexOf(f) > -1)
  })
} else {
  // 过滤 weex 
  builds = builds.filter(b => {
    return b.output.file.indexOf('weex') === -1
  })
}

// build -> buildEntry, 循环调用rollup.rollup()，传入config
build(builds)
```



#### Runtime Only 版本 和 Runtime + Compiler 版本 的区别

**Runtime Only 版本**

需要借助如 webpack 的 vue-loader 工具把 .vue 文件编译成 JavaScript

只包含运行时的 Vue.js 代码

体积也会更轻量。



**Runtime + Compiler 版本** 

使用了 Vue 的 template 属性并传入一个字符串

没有对代码做预编译，在客户端编译模板



在vue2.0中最终的渲染都是通过`render`函数，如果使用`template`属性，则需要编译成`render`函数，这个编译过程，**会发生运行时**，所以需要编译器。



## 2019.06.11

### vue-router - 月中公司考核复习

#### 基础

```html
<router-link to="/foo">Go to Foo</router-link>
```

当 `<router-link>` 对应的路由匹配成功，将自动设置 class 属性值 `.router-link-active`。



访问路由器

```js
this.$router 
```



访问当前页的路由

```js
this.$route.params.username
```



#### 动态路由匹配 - 路由传参

```js
routes: [
    // 动态路径参数 以冒号开头
    { path: '/user/:id', component: User }
  ]
```

当匹配到一个路由，参数值会被设置到`this.$route.params`

可以设置多段*路径参数*，对应的值都会设置到`this.$route.params`

```js
/user/:username/post/:post_id

/user/evan/post/123

{ username: 'evan', post_id: '123' }
```



复用组件时，想对路由参数的变化作出响应的话

用这个`beforeRouteUpdate` [导航守卫](https://router.vuejs.org/zh/guide/advanced/navigation-guards.html)

```js
beforeRouteUpdate (to, from, next) {
    // 响应路由变化
    // 记得调 next()
  }
```



匹配**任意路径**，使用通配符 (`*`)

```js
{
  // 会匹配所有路径
  path: '*'
}
{
  // 会匹配以 `/user-` 开头的任意路径
  path: '/user-*'
}
```

`{ path: '*' }` 通常用于客户端 404 错误。



当使用一个*通配符*时

`$route.params` 内会自动添加一个名为 `pathMatch` 参数

它包含了 URL 通过*通配符*被匹配的部分



#### 嵌套路由

页面上有一个`<router-view></router-view>`

是最顶层的出口

渲染最高级路由匹配到的组件



在 组件的模板添加一个 `<router-view>`

这就是一个嵌套的路由

要在嵌套的出口中渲染组件

**需要在 `VueRouter` 的参数中使用 `children` 配置**



**以 / 开头的嵌套路径会被当作根路径。也就是说，使用嵌套组件而无须设置嵌套的路径。**



还可以配置一个空路由，假如只访问父路由，嵌套可以匹配到这个组件，不设置的话，这里就是个空。



#### 编程式路由

就是不用标签，调取方法，触发路由变化

**this.$router.push**

```js
// 命名的路由 name
router.push({ name: 'user', params: { userId: '123' }})

// 带查询参数，path, 变成 /register?plan=private
router.push({ path: 'register', query: { plan: 'private' }})
```



**如果提供了 path，params 会被忽略**

**（上述例子中的 query 并不属于这种情况）**

**需要提供路由的 name 或手写完整的带有参数的 path**

```js
router.push({ name: 'user', params: { userId }}) // -> /user/123
router.push({ path: `/user/${userId}` }) // -> /user/123
// path + params 是不可以的
```



可选的在 `router.push` 或 `router.replace` 中提供 `onComplete`(完成) 和 `onAbort` （终止，包括**没动**和**重定向**）回调作为第二个和第三个参数。



如果路由没变，只是参数变了

你需要使用 [`beforeRouteUpdate`](https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html#响应路由参数的变化) 来响应这个变化



#### 导航守卫

> “导航”表示路由正在发生改变。

有 3 种机会植入路由导航过程中：

全局

单个路由独享

组件级

**参数或查询的改变并不会触发进入/离开的导航守卫**。



#### 完整的导航解析流程

> 1. 导航被触发。
> 2. 在失活的组件里调用离开守卫。
> 3. 调用全局的 `beforeEach` 守卫。
> 4. 在重用的组件里调用 `beforeRouteUpdate` 守卫 (2.2+)。
> 5. 在路由配置里调用 `beforeEnter`。
> 6. 解析异步路由组件。
> 7. 在被激活的组件里调用 `beforeRouteEnter`。
> 8. 调用全局的 `beforeResolve` 守卫 (2.5+)。
> 9. 导航被确认。
> 10. 调用全局的 `afterEach` 钩子。
> 11. 触发 DOM 更新。
> 12. 用创建好的实例调用 `beforeRouteEnter` 守卫中传给 `next` 的回调函数。



#### 路由元信息

定义路由的时候可以配置 `meta` 字段：

 `routes` 配置中的每个路由对象为 ***路由记录***。

当一个路由匹配成功后，他可能匹配多个路由记录

一个路由匹配到的所有路由记录会暴露为 `$route` 对象 (还有在导航守卫中的路由对象) 的 `$route.matched` 数组。



我们需要遍历 `$route.matched` 来检查路由记录中的 `meta` 字段。

```js
if (to.matched.some(record => record.meta.requiresAuth)) {
    // 访问这个路由需要授权，检察权限
    // 如果没有，跳转到登录界面
    if (!auth.loggedIn()) {
      next({
        path: '/login',
        query: { redirect: to.fullPath }
      })
    } else {
      next()
    }
```



### vue源码阅读

#### web/entry-runtime-with-compiler.js

##### vue实例的初始化

引入vue

```js
import Vue from './runtime/index'
```

模板编译

```js
import { compileToFunctions } from './compiler/index'
```

根元素挂载的一些处理，解析模板或者是元素，成render函数

#### runtime/index

##### vue的配置

引入vue

```js
import Vue from 'core/index'
```

设置Vue的config

包括一些工具方法

指令`directives`和组件`components`的功能

#### 真正初始化 Vue 的地方，在 `src/core/index.js` 中

```js
import Vue from './instance/index'
import { initGlobalAPI } from './global-api/index'

initGlobalAPI(Vue) // 初始化vue的全局API
```



##### Vue 的定义

```js
function Vue (options) {
  if (process.env.NODE_ENV !== 'production' &&
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword')
  }
  this._init(options)
}
```

通常的方式，如果没有使用new操作符调用Vue，this就会指向undefined，在开发环境给予提示。

要用 new 操作符

然后将配置传入vue的`_init`方法



这里，Vue实际上是一个Function实现的类。为啥不直接用类呢，function的形式可以直接传入各个初始化的函数，给予功能的添加（给 Vue 的 prototype 上扩展一些方法）。

```js
initMixin(Vue)
stateMixin(Vue)
```

类似于以上这种。



##### 全局API

除了在Vue的prototype上扩展方法，还会给Vue这个对象本身扩展全局的静态方法。

定义在 `src/core/global-api/index.js`

```js
// config
  const configDef = {}
  configDef.get = () => config
  if (process.env.NODE_ENV !== 'production') {
    configDef.set = () => {
      warn(
        'Do not replace the Vue.config object, set individual fields instead.'
      )
    }
  }
	// 给Vue定义config属性，setter被替换掉了，Vue实例化后，外部无法修改config
  Object.defineProperty(Vue, 'config', configDef)
```

定义一些工具方法，和一些公共API

```js
// util 里面暴露的方法最好不要依赖，可能会有变动
Vue.util = {
  warn,
  extend,
  mergeOptions,
  defineReactive
}

Vue.set = set
Vue.delete = del
Vue.nextTick = nextTick
```

配置Vue.options，以及内部的属性

```js
// shared/constants.js
export const ASSET_TYPES = [
  'component',
  'directive',
  'filter'
]
```



```js
Vue.options = Object.create(null)
ASSET_TYPES.forEach(type => {
  Vue.options[type + 's'] = Object.create(null)
})
```



将`keep-alive`这个组件混合到`Vue.options.components`

```js
extend(Vue.options.components, builtInComponents)
```



extend 向对象里面混合属性

```js
export function extend (to: Object, _from: ?Object): Object {
  for (const key in _from) {
    to[key] = _from[key]
  }
  return to
}
```



builtInComponents

```js
import KeepAlive from './keep-alive'

export default {
  KeepAlive
}
```



在core/util/index.js看到

```js
export * from 'shared/util'
```

这样做直接把 shared/util 导出的内容直接导出了。



### 数据驱动

视图由数据驱动生成，先来看一下Vue是如何实现

####【模板和数据】 如何渲染成最终的DOM



