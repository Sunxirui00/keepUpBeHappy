# 学习周报

2019.06.08 - 2019.06.15

## 2019.06.10

### TypeScript的学习

#### Rest and Spread 操作符

用处：

1. 接收参数，是一个数组

   ```ts
   function func1(...args){
   	args.forEach(function(arg){
   		console.log(arg)
   	})
   }
   
   func1(1, 2, 3)
   ```

2. 传递参数，入参是，形参是多个

   ```ts
   function func1(a, b, c){
   	console.log(a)
   	console.log(b)
   	console.log(c)
   }
   
   func1(...[1, 2])
   ```

#### 类 Class

1. class的属性的访问控制符，分为三种，公开的，私有的，被保护的

2. 构造器函数construtor在new一个实例的时候，会被调用一次

3. 类在某种意义上（我先这么分类，不知道是不是有这种界定）有两种属性的声明方式：形参（隐式声明），显示声明。

   ```ts
   class Person{
   
   	name; // 默认的访问控制符是，public
   	
   	construtor(age: string){};
   	
   	eat(){
   		console.log(this.name);
   		console.log(this.age); // 这里会报错，因为并没有显示声明age，必须在构造器的形参前，声明访问控制符为：public
   	};
   	
   }
   ```

4. 子类的构造函数如果有，就必须调用一下父类的构造函数，使用`super`关键字

5. `super`的另外一个用法是调用父类上面的方法

6. 不想被外界访问的方法或者属性就可以直接使用访问控制符`private`



#### 泛型

一种参数化的类型，一般用来限制集合

这种类型可以是推断的。

可以是类。

可以是接口。



#### 接口

用来建立某种**代码约定**，使得其他开发者在**调用**某种方法或者**创建**新的类时，必须遵循接口所定义的代码约定。

用法

1. 方法参数的类型声明
2. 实现这个接口的类
   * 当一个类实现一个接口的时候，这个类必须实现这个接口里面的方法



#### 模块 Module

将代码分割成可重用的单元。

可以决定哪些资源（类，方法，属性）暴露，哪些只在模块内部使用



#### 注解

注解是给指定的库、框架用的，告诉如何去处理程序的元素(属性、方法、类)



#### 类型定义文件`*.d.ts`

在TS是使用已有的JS的工具包、库



### Flow js的静态类型检查

#### 工作方式2种

* 类型推断

* 类型注释

注释的方式类似于TS，但是还是有一些不同的

1. 可以为 `null` 或者 `undefined`，如下

```js
/*@flow*/
var foo: ?string = null;
```

​	foo可以是字符串或者是null\undefined。

​	对于js的两种类型null\undefined，flow的类型是 `null` 和 `void`

​	可选类型的`?`是在类型的前面，`:`的后面

2. 强制类型转换的应用

   ```js
   // @flow
   function acceptsBoolean(value: boolean){}
   
   acceptsBoolean(0); // 必须传入布尔值
   // 可以进行如下转化
   acceptsBoolean(Boolean(0));
   acceptsBoolean(!!0);
   ```

3. 对象的可选属性

   ```js
   { propertyName?: string }
   ```

   在属性键的后面。

4. 值可以限制成确定的值，使用冒号

5. 类型使用`mixed`可以是用在形参上，所有类型的值都可以传入，但是

   1. 有返回值，要确定值类型，这个形参在函数内部需要进行类型检查之后才可以使用。
   2. 没有返回值，那无所谓了


别的flow的内容，在vue源码阅读的过程中，再看。



### vue源码阅读

#### Flow 在 Vue.js 源码中的应用

关键词： `libdef`，`Rollup`

`libdef`： 可以用来识别这些第三方库或者是自定义类型



vuejs基于Rollup构建，vue的构建打包过程，有很多版本的vuejs。Rollup的配置文件`scripts/config.js`，先从配置文件读取配置，再通过命令行参数对构建配置做过滤，各版本的对应的入口在`entry: resolve('xxx/xxx.js'),`，最终编译的版本在` dest: resolve('dist/xxx.js')`。

构建的时候执行，`node scripts/build.js`，这个文件是构建的入口。

```js
// 获取各种构建方式的配置
let builds = require('./config').getAllBuilds()

// 构建语句的环境参数有没有，node scripts/build.js， 是没有的
if (process.argv[2]) {
  const filters = process.argv[2].split(',')
  builds = builds.filter(b => {
    return filters.some(f => b.output.file.indexOf(f) > -1 || b._name.indexOf(f) > -1)
  })
} else {
  // 过滤 weex 
  builds = builds.filter(b => {
    return b.output.file.indexOf('weex') === -1
  })
}

// build -> buildEntry, 循环调用rollup.rollup()，传入config
build(builds)
```



#### Runtime Only 版本 和 Runtime + Compiler 版本 的区别

**Runtime Only 版本**

需要借助如 webpack 的 vue-loader 工具把 .vue 文件编译成 JavaScript

只包含运行时的 Vue.js 代码

体积也会更轻量。



**Runtime + Compiler 版本** 

使用了 Vue 的 template 属性并传入一个字符串

没有对代码做预编译，在客户端编译模板



在vue2.0中最终的渲染都是通过`render`函数，如果使用`template`属性，则需要编译成`render`函数，这个编译过程，**会发生运行时**，所以需要编译器。









