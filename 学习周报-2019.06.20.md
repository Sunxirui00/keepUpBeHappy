# 学习周报

2019.06.08 - 2019.06.15

## 2019.06.17

### vue源码阅读4

#### `createElement`

首先，`createElement`是对`_createElement`的封装

`createElement`有6个形参，`_createElement`有5个

假如没有传`data`，`data`是第三个形参，就把`children`和`normalizationType`往前赋值，并且对形参`alwaysNormalize`进行转换。

```ts
export function createElement (
  context: Component, 
  tag: any, 
  data: any, 
  children: any, 
  normalizationType: any, 
  alwaysNormalize: boolean
): VNode | Array<VNode> {
  // 往前赋值
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children
    children = data
    data = undefined
  }
  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE // 转换 normalizationType = 2
  }
  return _createElement(context, tag, data, children, normalizationType)
}
```

#### `_createElement`

```ts
export function _createElement (
  context: Component, // VNode 的上下文环境, 它是 Component 类型
  tag?: string | Class<Component> | Function | Object, // 标签，它可以是一个字符串，也可以是一个 Component
  data?: VNodeData, // data 表示 VNode 的数据，它是一个 VNodeData 类型
  children?: any, // 子节点，它是任意类型的，它接下来需要被规范为标准的 VNode 数组
  normalizationType?: number // normalizationType 表示子节点规范的类型，类型不同规范的方法也就不一样，它主要是参考 render 函数是编译生成的还是用户手写的。
): VNode | Array<VNode> {
}
```

`createElement` 函数的流程略微有点多，我们接下来主要分析 2 个重点的流程

* `children` 的规范化

* VNode 的创建

#### `children` 的规范化

 Virtual DOM 实际上是树状结构，可能会有若干个子节点

子节点也是VNode类型。

但是接收的children参数是任意类型，那需要转化一下

##### 根据normalizationType的不同

调用 `normalizeChildren(children)` 或者 `simpleNormalizeChildren(children)`



`normalizeChildren` 方法的调用场景有 2 种，

一个场景是 `render` 函数是用户手写的，当 `children` 只有一个节点的时候，Vue.js 从接口层面允许用户把 `children` 写成基础类型用来创建单个简单的文本节点，这种情况会调用 `createTextVNode` 创建一个文本节点的 VNode；

另一个场景是当编译 `slot`、`v-for` 的时候会产生嵌套数组的情况，会调用 `normalizeArrayChildren` 方法

```ts
function normalizeArrayChildren (children: any, nestedIndex?: string): Array<VNode> {
  const res = []
  let i, c, lastIndex, last
  for (i = 0; i < children.length; i++) {
    c = children[i]
    if (isUndef(c) || typeof c === 'boolean') continue
    lastIndex = res.length - 1
    last = res[lastIndex]
    //  nested
    if (Array.isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, `${nestedIndex || ''}_${i}`)
        if (isTextNode(c[0]) && isTextNode(last)) {
          // 两个连续的 `text` 节点，合并成一个 `text` 节点 
          res[lastIndex] = createTextVNode(last.text + (c[0]: any).text)
          c.shift()
        }
        res.push.apply(res, c)
      }
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        // 两个连续的 `text` 节点，合并成一个 `text` 节点 
        res[lastIndex] = createTextVNode(last.text + c)
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c))
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // 两个连续的 `text` 节点，合并成一个 `text` 节点 
        res[lastIndex] = createTextVNode(last.text + c.text)
      } else {
        
        // 如果 `children` 是一个列表并且列表还存在嵌套的情况
				 // 则根据 `nestedIndex` 去更新它的 key。
        
        if (isTrue(children._isVList) &&
          isDef(c.tag) &&
          isUndef(c.key) &&
          isDef(nestedIndex)) {
          c.key = `__vlist${nestedIndex}_${i}__`
        }
        res.push(c)
      }
    }
  }
  return res
}
```

`normalizeArrayChildren` 接收 2 个参数

`children` 表示要规范的子节点，`nestedIndex` 表示嵌套的索引，因为单个 `child` 可能是一个数组类型。

 `normalizeArrayChildren` 主要的逻辑就是遍历 `children`，获得单个节点 `c`

然后对 `c` 的类型判断，如果是一个数组类型，则递归调用 `normalizeArrayChildren`; 

如果是基础类型，则通过 `createTextVNode` 方法转换成 VNode 类型；

否则就已经是 VNode 类型了

如果 `children` 是一个列表并且列表还存在嵌套的情况

则根据 `nestedIndex` 去更新它的 key。

（ 这里需要注意一点，在遍历的过程中，对这 3 种情况都做了如下处理：

如果存在两个连续的 `text` 节点，会把它们合并成一个 `text` 节点 ）

经过对 `children` 的规范化，`children` 变成了一个类型为 VNode 的 Array。



`simpleNormalizeChildren` 方法调用场景是 `render` 函数是编译生成的。

理论上编译生成的 `children` 都已经是 VNode 类型的，但这里有一个例外，就是 `functional component` 函数式组件返回的是一个数组而不是一个根节点，所以会通过 `Array.prototype.concat` 方法把整个 `children` 数组打平，让它的深度只有一层。



#### VNode 的创建

```ts
let vnode, ns
if (typeof tag === 'string') {
  let Ctor
  ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag)
  if (config.isReservedTag(tag)) {
    // 是内置的节点，直接创建普通的VNode
    vnode = new VNode(
      config.parsePlatformTagName(tag), data, children,
      undefined, undefined, context
    )
  } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
    // 是已经注册的组件名，创建一个组件类型的VNode
    vnode = createComponent(Ctor, data, context, children, tag)
  } else {
    // 创建一个未知的标签的 VNode。 
    vnode = new VNode(
      tag, data, children,
      undefined, undefined, context
    )
  }
} else {
  // tag不是string类型，就是Component类型
  // 直接创建组件类型VNode
  vnode = createComponent(tag, data, context, children)
}
```

这里先对 `tag` 做判断，

* 是 `string` 类型，则接着判断如果是内置的一些节点，则直接创建一个普通 VNode，

* 是为已注册的组件名，则通过 `createComponent` 创建一个组件类型的 VNode，

* 否则创建一个未知的标签的 VNode。 

这样，VNode下面也是VNode，就形成了VNode Tree，很好的描述了DOM Tree，接下来就是渲染啦



### wx-js-jdk 支付

在微信公众号调取微信支付

一共分为5步：

#### Step-1：code换取openid

#### Step-2：预支付

#### Step-3：返回支付参数

#### Step-4：发起支付

#### Step-5：确认支付结果



